[1mdiff --git a/Bitmasking/No.of1bits/OneBitCounter.java b/Bitmasking/No.of1bits/OneBitCounter.java[m
[1mnew file mode 100644[m
[1mindex 0000000..26f6e4f[m
[1m--- /dev/null[m
[1m+++ b/Bitmasking/No.of1bits/OneBitCounter.java[m
[36m@@ -0,0 +1,20 @@[m
[32m+[m[32mimport java.util.Scanner;[m
[32m+[m
[32m+[m[32mpublic class OneBitCounter {[m
[32m+[m[32m    public static int noOfOneBits(int n) {[m
[32m+[m[32m        int cnt = 0;[m
[32m+[m[32m        for (int i = 0; i < 31; i++) {[m
[32m+[m[32m            if ((n & (1 << i)) != 0) {[m
[32m+[m[32m                cnt++;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return cnt;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    public static void main(String[] args) {[m
[32m+[m[32m        Scanner sc = new Scanner(System.in);[m
[32m+[m[32m        System.out.print("Enter a number: ");[m
[32m+[m[32m        int n = sc.nextInt();[m
[32m+[m[32m        System.out.println("Number of 1-bits: " + noOfOneBits(n));[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/Bitmasking/No.of1bits/markdown.md b/Bitmasking/No.of1bits/markdown.md[m
[1mnew file mode 100644[m
[1mindex 0000000..21ff966[m
[1m--- /dev/null[m
[1m+++ b/Bitmasking/No.of1bits/markdown.md[m
[36m@@ -0,0 +1,59 @@[m
[32m+[m[32m# 🧮 Count Number of 1-Bits (Set Bits)[m
[32m+[m
[32m+[m[32m## ✅ Problem Statement[m
[32m+[m
[32m+[m[32mGiven an integer `n`, return the number of `1`s in its binary representation. This is also known as the **Hamming weight** or **population count**.[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m## 📥 Input[m
[32m+[m
[32m+[m[32m- A single integer `n` (can be positive or negative depending on implementation)[m
[32m+[m
[32m+[m[32m## 📤 Output[m
[32m+[m
[32m+[m[32m- An integer representing the count of `1` bits in the binary representation of `n`.[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m## 🧪 Example[m
[32m+[m
[32m+[m[32m### Input:[m
[32m+[m[32mn = 13[m
[32m+[m
[32m+[m[32m### Binary Representation:[m
[32m+[m[32m13 in binary = 00000000000000000000000000001101[m
[32m+[m
[32m+[m[32m### Output:[m
[32m+[m[32m3[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m## 🧠 Explanation[m
[32m+[m
[32m+[m[32mWe iterate through each bit position from `0` to `30` (assuming a 32-bit signed integer and ignoring the sign bit). At each position `i`, we check if the `i-th` bit is set using the expression:[m
[32m+[m
[32m+[m[32m```python[m
[32m+[m[32mif n & (1 << i):[m
[32m+[m[32mIf the bit is set, we increment our counter. Finally, we return the total count.[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m⏱️ Time Complexity[m
[32m+[m[32mO(31) → Constant time since the loop runs a fixed number of times (31 iterations).[m
[32m+[m
[32m+[m[32mAlternatively, O(log n) if using optimized methods like Brian Kernighan’s algorithm.[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m📦 Space Complexity[m
[32m+[m[32mO(1) → Only a single counter variable is used; no extra space required.[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m📌 Notes[m
[32m+[m[32mFor unsigned integers, you may loop through all 32 bits.[m
[32m+[m
[32m+[m[32mFor negative numbers, behavior depends on two's complement representation.[m
[32m+[m
[32m+[m[32mConsider using bin(n).count('1') for a Pythonic shortcut (though less educational for bit manipulation practice).[m
\ No newline at end of file[m
[1mdiff --git a/Bitmasking/No.of1bits/noofonebits.cpp b/Bitmasking/No.of1bits/noofonebits.cpp[m
[1mnew file mode 100644[m
[1mindex 0000000..c6a9109[m
[1m--- /dev/null[m
[1m+++ b/Bitmasking/No.of1bits/noofonebits.cpp[m
[36m@@ -0,0 +1,20 @@[m
[32m+[m[32m#include <iostream>[m
[32m+[m[32musing namespace std;[m
[32m+[m
[32m+[m[32mint noOfOneBits(int n) {[m
[32m+[m[32m    int cnt = 0;[m
[32m+[m[32m    for (int i = 0; i < 31; i++) {[m
[32m+[m[32m        if (n & (1 << i)) {[m
[32m+[m[32m            cnt++;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    return cnt;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint main() {[m
[32m+[m[32m    int n;[m
[32m+[m[32m    cout << "Enter a number: ";[m
[32m+[m[32m    cin >> n;[m
[32m+[m[32m    cout << "Number of 1-bits: " << noOfOneBits(n) << endl;[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[1mdiff --git a/Bitmasking/No.of1bits/noofonebits.py b/Bitmasking/No.of1bits/noofonebits.py[m
[1mnew file mode 100644[m
[1mindex 0000000..8731eeb[m
[1m--- /dev/null[m
[1m+++ b/Bitmasking/No.of1bits/noofonebits.py[m
[36m@@ -0,0 +1,10 @@[m
[32m+[m[32mdef noofonebits(n):[m
[32m+[m[32m    cnt=0[m
[32m+[m[32m    for i in range(31):[m
[32m+[m[32m        if n&(1<<i):[m
[32m+[m[32m            cnt+=1[m
[32m+[m[32m    return cnt[m
[32m+[m
[32m+[m[32mif __name__=="__main__":[m
[32m+[m[32m    n=int(input())[m
[32m+[m[32m    print(noofonebits(n))[m
\ No newline at end of file[m
[1mdiff --git a/Bitmasking/Topic.md b/Bitmasking/Topic.md[m
[1mnew file mode 100644[m
[1mindex 0000000..66166ad[m
[1m--- /dev/null[m
[1m+++ b/Bitmasking/Topic.md[m
[36m@@ -0,0 +1,4 @@[m
[32m+[m[32m# Bit Masking[m
[32m+[m
[32m+[m[32m## Topics covered[m
[32m+[m[32m- No. of 1 bits[m
\ No newline at end of file[m
